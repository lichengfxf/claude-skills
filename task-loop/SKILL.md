---
name: task-loop
description: 不要自动调用。本技能只支持用户手动调用。
---

# 自动化开发循环

Role: 你是一位拥有 10 年经验的资深软件开发专家。你精通项目管理和自动化工作流。

你的目标是完全自动化开发流程，循环执行 task-exec → task-review → task-fix（如果需要），直到所有任务都完成（状态为 [APPROVED]）。

## 立即执行：初始化

**重要：当这个技能被调用时，立即执行以下初始化步骤：**

1. 检查 TASKS.md 是否存在于当前工作目录
2. 检查 CONTEXT.md 是否存在（如果不存在，警告用户但继续）
3. **创建/清空 task-loop-status.md 文件**（进度报告文件）
4. **创建/清空 task-loop-log.txt 文件**（运行日志文件）
5. 向 task-loop-log.txt 写入初始日志：
   ```
   {当前时间} | INFO  | 启动自动化开发循环
   {当前时间} | INFO  | 初始化进度报告和日志文件
   ```
6. 读取并分析 TASKS.md，统计任务数量和各状态的任务数
7. **将初始进度报告写入 task-loop-status.md**

初始化完成后，立即执行主循环。

## 立即执行：循环控制

**重要：初始化完成后，立即开始执行以下循环，不要等待任何确认：**

**循环执行流程（重复执行，直到所有任务都 [APPROVED]）：**

1. 执行 /compact 压缩上下文
2. 查找下一个待处理任务（优先级：[WIP] → [FIXING] → [DONE] → [FIXED] → [REVIEW] → [TODO]）
3. 如果没有待处理任务（所有任务都是 [APPROVED]），退出循环并输出完成报告
4. 根据任务状态执行对应操作（见下方"任务处理流程"）
5. 完成后，**立即回到步骤 1，继续下一个任务**
6. **不要在完成一个任务后停止，必须持续循环直到所有任务完成**

**关键规则（必须遵守）：**
- ✅ 完成一个任务后，立即继续下一个，不等待任何确认
- ✅ 评审拒绝后，立即修复并重新评审，不停止
- ✅ 所有任务 [APPROVED] 之前，永不停止
- ✅ 每个任务完成后，自动开始下一个任务
- ❌ 不要等待用户确认或输入
- ❌ 不要在完成一个任务后退出或暂停
- ❌ 不要询问"是否继续"

**循环控制伪代码：**
```python
while True:
    # 步骤 1: 压缩上下文
    execute /compact

    # 步骤 2: 查找待处理任务
    task = find_next_task(
        priority=[WIP, FIXING, DONE, FIXED, REVIEW, TODO]
    )

    # 步骤 3: 检查是否全部完成
    if task is None:  # 所有任务都是 [APPROVED]
        print("所有任务已完成！")
        break  # 退出循环

    # 步骤 4: 执行任务
    if task.status == TODO:
        execute_task_exec(task)
        execute_task_review(task)
    elif task.status == WIP:
        continue_task_exec(task)  # 恢复并完成
        execute_task_review(task)
    elif task.status == REVIEW:
        continue_task_review(task)  # 完成评审
    elif task.status == DONE:
        execute_task_review(task)
    elif task.status == FIXED:
        execute_task_review(task)  # 重新评审
    elif task.status == REJECTED:
        execute_task_fix(task)
        execute_task_review(task)
    elif task.status == FIXING:
        continue_task_fix(task)  # 恢复并完成修复
        execute_task_review(task)

    # 步骤 5: 立即继续，不停止
    # 循环回到步骤 1
```

## 重要：上下文管理

### 每个任务循环开始前
**必须使用 `/compact` 命令压缩当前会话的上下文**，以避免 Token 消耗过大和保持处理效率。

压缩上下文的操作：
```markdown
在每个任务循环开始前，执行以下步骤：

1. 执行 /compact 命令压缩上下文
2. 等待上下文压缩完成
3. 读取当前任务信息（任务编号、描述、状态）
4. 读取必要文件：
   - TASKS.md（查看任务状态）
   - CONTEXT.md（获取项目上下文，如果存在）
   - task-{编号}.review（对应的评审报告，如果存在）
5. 继续执行当前任务
```

重要提示：
- **在初始化完成后立即执行一次 /compact**，压缩加载技能文件的上下文
- **在每个任务开始前都执行 /compact**，包括：
  - 从 [TODO] 开始新任务前
  - 从 [WIP] 恢复任务前
  - 从 [FIXING] 恢复修复前
  - 从 [DONE]/[FIXED]/[REVIEW] 开始评审前
- **在 task-exec、task-review、task-fix 之间也执行 /compact**

这样做的好处：
- 大幅减少 Token 消耗
- 提高响应速度
- 避免上下文过长导致的质量下降
- 每个任务都"重新开始"，更符合真实开发流程

### 文件输出
- **进度报告**：`task-loop-status.md` - 实时更新的当前状态
- **运行日志**：`task-loop-log.txt` - 完整的操作日志

## 工作流程

### 主循环
```
┌─────────────────────────────────────────────────────────┐
│  1. 读取 TASKS.md，检查是否有待处理的任务              │
│     按优先级查找：                                      │
│     - 查找 [WIP] 任务（开发进行中被打断）⭐ 最高优先级  │
│     - 查找 [FIXING] 任务（修复进行中被打断）            │
│     - 查找 [DONE] 任务（开发完成，待评审）              │
│     - 查找 [FIXED] 任务（修复完成，待重新评审）          │
│     - 查找 [REVIEW] 任务（评审中）                      │
│     - 查找 [TODO] 任务（待开发）                        │
└─────────────────────────────────────────────────────────┘
                    ↓
            是否有待处理任务？
                    ↓
         ┌──────────┴──────────┐
         │ 是                   │ 否
         ↓                      ↓
┌──────────────────┐    ┌─────────────────┐
│ 2. 确定任务类型   │    │ 所有任务已完成   │
│    - [TODO]      │    │ 退出循环         │
│      → 执行      │    └─────────────────┘
│    - [REVIEW]    │
│      → 评审      │
│    - [FIXED]     │
│      → 评审      │
└──────────────────┘
         ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 根据任务类型执行相应操作                             │
│                                                          │
│    情况 A: [TODO] 任务                                   │
│    ┌────────────────────────────────────────────┐       │
│    │ 3.1 调用 task-exec 执行任务                 │       │
│    │     - 将 [TODO] 改为 [WIP]                   │       │
│    │     - 实现功能代码                           │       │
│    │     - 将 [WIP] 改为 [DONE]                   │       │
│    │     - 提交代码                               │       │
│    └────────────────────────────────────────────┘       │
│                    ↓                                     │
│    ┌────────────────────────────────────────────┐       │
│    │ 3.2 调用 task-review 评审任务               │       │
│    │     - 将 [DONE] 改为 [REVIEW]                │       │
│    │     - 创建评审报告文件                       │       │
│    │     - 判断：通过 [APPROVED] 或拒绝 [REJECTED]│     │
│    └────────────────────────────────────────────┘       │
│                    ↓                                     │
│         ┌──────────┴──────────┐                         │
│         │ 通过                 │ 拒绝                    │
│         ↓                      ↓                         │
│    ┌─────────┐         ┌──────────────────┐             │
│    │ 继续下一个 │         │ 3.3 调用 task-fix │             │
│    │  任务    │         │     - 将 [REJECTED]│            │
│    └─────────┘         │       改为 [FIXING] │            │
│                        │     - 修复问题     │            │
│                        │     - 将 [FIXING]  │            │
│                        │       改为 [FIXED]  │            │
│                        │     - 提交修复代码  │            │
│                        └───────────────────┘            │
│                               ↓                          │
│                    ┌────────────────────────────────────┐│
│                    │ 3.4 重新调用 task-review            ││
│                    │     - 将 [FIXED] 改为 [REVIEW]      ││
│                    │     - 更新评审报告                  ││
│                    │     - 判断：通过或拒绝              ││
│                    └────────────────────────────────────┘│
│                               ↓                          │
│                    ┌──────────┴──────────┐              │
│                    │ 通过                 │ 拒绝          │
│                    ↓                      ↓              │
│               ┌─────────┐         回到 3.3              │
│               │ 继续下一个 │                               │
│               │  任务    │                               │
│               └─────────┘                               │
│                                                          │
│    情况 B: [REVIEW] 任务（遗留任务）                     │
│    ┌────────────────────────────────────────────┐       │
│    │ 直接调用 task-review 完成评审                │       │
│    │     - 将 [REVIEW] 改为 [APPROVED]/[REJECTED]│      │
│    └────────────────────────────────────────────┘       │
│                                                          │
│    情况 C: [FIXED] 任务（修复后待重新评审）              │
│    ┌────────────────────────────────────────────┐       │
│    │ 直接调用 task-review 重新评审                │       │
│    │     - 将 [FIXED] 改为 [REVIEW]               │       │
│    │     - 将 [REVIEW] 改为 [APPROVED]/[REJECTED]│      │
│    └────────────────────────────────────────────┘       │
│                                                          │
│    情况 D: [WIP] 任务（开发进行中被打断）                │
│    ┌────────────────────────────────────────────┐       │
│    │ 继续完成当前任务                            │       │
│    │     - 读取当前进度和已完成的代码             │       │
│    │     - 继续开发直到完成                       │       │
│    │     - 将 [WIP] 改为 [DONE]                  │       │
│    │     - 然后调用 task-review                  │       │
│    └────────────────────────────────────────────┘       │
│                                                          │
│    情况 E: [FIXING] 任务（修复进行中被打断）              │
│    ┌────────────────────────────────────────────┐       │
│    │ 继续完成修复                                │       │
│    │     - 读取评审意见和当前修复进度             │       │
│    │     - 继续修复直到完成                       │       │
│    │     - 将 [FIXING] 改为 [FIXED]              │       │
│    │     - 然后调用 task-review 重新评审          │       │
│    └────────────────────────────────────────────┘       │
│                                                          │
│    情况 F: [DONE] 任务（开发完成，待评审）                │
│    ┌────────────────────────────────────────────┐       │
│    │ 直接调用 task-review 评审                   │       │
│    │     - 将 [DONE] 改为 [REVIEW]               │       │
│    │     - 将 [REVIEW] 改为 [APPROVED]/[REJECTED]│      │
│    └────────────────────────────────────────────┘       │
└─────────────────────────────────────────────────────────┘
         ↓
    回到步骤 1，继续循环
```

## 执行规则

### 优先级处理顺序
处理中断恢复时的优先级（从高到低）：
1. **[WIP]** - 开发进行中被打断，优先完成当前任务
2. **[FIXING]** - 修复进行中被打断，优先完成修复
3. **[DONE]** - 开发完成但未评审，需要评审
4. **[FIXED]** - 修复完成待重新评审
5. **[REVIEW]** - 评审中的任务
6. **[TODO]** - 新任务按顺序执行

**原因**：中间状态的任务（WIP、FIXING、DONE）表示已经投入了工作，应该优先完成，避免浪费已有进展。

### 任务查找规则
```markdown
优先查找：[WIP] → [FIXING] → [DONE] → [FIXED] → [REVIEW] → [TODO]

在同一优先级内，按编号顺序：
- 01-001, 01-002, 01-003...
- 02-001, 02-002, 02-003...
```

### 中断恢复说明
当循环被中断后重新启动时：
1. 检查是否有 [WIP] 或 [FIXING] 任务（进行中的任务）
2. 如果有，优先恢复这些任务
3. 如果没有，检查 [DONE] 或 [FIXED] 任务（待评审的任务）
4. 最后处理 [TODO] 任务（新任务）

这样可以确保：
- 不会重复开始已进行中的任务
- 已完成的工作不会丢失
- 任务流程的连续性

### 状态转换规则
```markdown
# 开发流程
[TODO] → [WIP] → [DONE] → [REVIEW]

# 评审流程
[REVIEW] → [APPROVED]  # 通过
[REVIEW] → [REJECTED]  # 拒绝

# 修复流程
[REJECTED] → [FIXING] → [FIXED] → [REVIEW]

# 重新评审
[FIXED] → [REVIEW] → [APPROVED]/[REJECTED]
```

### 中断和恢复
- **遇到错误时**：记录错误信息，暂停循环，让用户决定是否继续
- **遇到冲突时**：提示用户解决冲突，等待用户恢复
- **手动干预**：用户可随时中断循环，手动调整任务状态

## 循环控制

### 每次迭代前检查
- [ ] TASKS.md 文件是否存在且有效
- [ ] 是否有 CONTEXT.md（可选，但推荐）
- [ ] 工作目录是否为 git 仓库
- [ ] 是否有未提交的更改（提示用户）

### 完成条件
循环在以下情况下结束：
1. ✅ 所有任务状态都是 [APPROVED]
2. ⚠️ 用户手动中断
3. ❌ 遇到无法恢复的错误

### 进度报告（输出到 task-loop-status.md）
每完成一个任务或修复后，更新进度报告文件：

```markdown
# 自动化开发循环 - 进度报告

更新时间：2025-02-24 16:30:00

## 当前状态
- 总任务数：15
- 已完成：8 [APPROVED]
- 进行中：1 [WIP]
- 待评审：1 [DONE]
- 评审中：1 [REVIEW]
- 待开发：3 [TODO]
- 修复中：1 [FIXING]

## 最近完成
- ✅ 01-005 实现登录 API [APPROVED]
- ✅ 01-006 实现登出功能 [APPROVED]

## 正在处理
- 🔨 01-007 添加 token 刷新机制 [WIP]
- 👀 01-008 实现密码重置 [REVIEW]
- 🔧 01-009 添加邮箱验证 [FIXING]

## 下一步
- ⏭️ 将处理：01-010 实现用户资料管理

## 里程碑进度
- 🎯 里程碑 1 (MVP)：7/8 完成
- 🎯 里程碑 2 (增强)：1/7 完成

## 循环统计
- 已完成循环：15 次
- 修复次数：2 次
- 评审通过率：93%
```

### 运行日志（输出到 task-loop-log.txt）
记录所有操作到日志文件：

```
2025-02-24 10:00:00 | INFO  | 启动自动化开发循环
2025-02-24 10:00:01 | INFO  | 读取 TASKS.md
2025-02-24 10:00:02 | INFO  | 发现 15 个任务，0 个已完成
2025-02-24 10:00:03 | INFO  | 初始化进度报告和日志文件
2025-02-24 10:00:04 | INFO  | 执行 /compact 压缩上下文
2025-02-24 10:00:05 | INFO  | 上下文已压缩
2025-02-24 10:00:06 | TASK  | 读取任务 01-001：初始化项目结构
2025-02-24 10:00:07 | TASK  | 执行 task-exec：01-001 初始化项目结构
2025-02-24 10:15:30 | TASK  | 完成 task-exec，状态：[WIP] → [DONE]
2025-02-24 10:15:31 | INFO  | 执行 /compact 压缩上下文
2025-02-24 10:15:32 | INFO  | 上下文已压缩
2025-02-24 10:15:33 | TASK  | 执行 task-review：01-001
2025-02-24 10:20:15 | TASK  | 完成 task-review，状态：[REVIEW] → [APPROVED]
2025-02-24 10:20:16 | INFO  | 任务 01-001 完成 [APPROVED]
2025-02-24 10:20:17 | INFO  | 更新进度报告
2025-02-24 10:20:18 | INFO  | 执行 /compact 压缩上下文
2025-02-24 10:20:19 | INFO  | 上下文已压缩
2025-02-24 10:20:20 | TASK  | 读取任务 01-002：配置 TypeScript
2025-02-24 10:20:21 | TASK  | 执行 task-exec：01-002 配置 TypeScript
...
```

日志格式：
```
时间戳 | 级别 | 消息
```

日志级别：
- **INFO** - 一般信息
- **TASK** - 任务执行
- **REVIEW** - 评审操作
- **FIX** - 修复操作
- **WARN** - 警告
- **ERROR** - 错误
- **SUCCESS** - 成功完成

## 使用说明

### 启动自动循环
调用本技能（/task-loop）时，会自动执行初始化并开始循环。

### 从特定任务开始
如果需要从特定任务开始，可以在调用技能前：
1. 将该任务之前所有任务标记为 [APPROVED]
2. 将该任务标记为 [TODO]（或其他需要恢复的状态）
3. 调用 /task-loop

循环会：
1. 执行初始化（创建/清空状态和日志文件）
2. 读取当前状态
3. 从第一个未完成的任务继续

### 暂停和恢复
- **暂停**：用户请求停止时，写入日志并保存当前状态
  ```
  {时间戳} | INFO | 收到暂停请求，保存当前状态
  {时间戳} | INFO | 当前处理任务：01-005 [WIP]
  ```
- **恢复**：重新调用 /task-loop，会重新初始化并从当前状态继续
  ```
  {时间戳} | INFO | 恢复自动化开发循环
  {时间戳} | INFO | 从任务 01-005 [WIP] 继续
  ```

## 注意事项

### 安全检查
每次迭代开始前检查：
- 不修改核心技能文件（task-*/SKILL.md）
- 不删除或破坏用户数据
- 不提交包含敏感信息的代码

### 最佳实践
1. **首次运行前**：
   - 确保 TASKS.md 已正确创建
   - 确保项目结构已初始化
   - 建议先手动执行第一个任务验证流程

2. **运行期间**：
   - 定期检查 git 提交历史
   - 查看评审报告文件
   - 监控进度报告

3. **遇到问题时**：
   - 检查 TASKS.md 中的任务状态
   - 查看对应的 .review 文件
   - 可以手动调整状态后恢复循环

### 日志记录
**重要**：所有日志都记录到 `task-loop-log.txt` 文件中，而不是 TASKS.md。

每次操作都要追加日志到 task-loop-log.txt，包括：
- 启动和恢复
- 每个任务的开始和完成
- 状态转换
- 评审结果
- 修复操作
- 错误和警告
- 进度更新

### 任务循环执行流程

### 每个任务循环的标准流程

```markdown
步骤 0：压缩上下文（最优先）
─────────────────────────────────────────
操作：执行 /compact 命令
日志：{时间戳} | INFO | 执行 /compact 压缩上下文
说明：在开始任何任务前，先压缩上下文以减少 Token 消耗

步骤 1：读取任务信息
─────────────────────────────────────────
操作：从 TASKS.md 读取当前任务的完整信息
日志：{时间戳} | TASK | 读取任务 {编号}：{描述}

步骤 2：执行任务（根据状态）
─────────────────────────────────────────
如果是 [TODO]：
  日志：{时间戳} | TASK | 执行 task-exec：{编号} {描述}
  操作：调用 task-exec 技能
  日志：{时间戳} | TASK | 完成 task-exec，状态：[TODO] → [WIP] → [DONE]

  日志：{时间戳} | REVIEW | 执行 task-review：{编号}
  操作：调用 task-review 技能
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[DONE] → [REVIEW] → {结果}

如果是 [WIP]（开发进行中被打断）：
  日志：{时间戳} | INFO | 恢复开发中任务：{编号}
  操作：读取当前进度和已完成的代码，继续开发
  日志：{时间戳} | TASK | 继续开发，状态：[WIP] → [DONE]
  日志：{时间戳} | REVIEW | 执行 task-review：{编号}
  操作：调用 task-review 技能
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[DONE] → [REVIEW] → {结果}

如果是 [FIXING]（修复进行中被打断）：
  日志：{时间戳} | INFO | 恢复修复中任务：{编号}
  操作：读取评审意见和当前修复进度，继续修复
  日志：{时间戳} | FIX | 继续修复，状态：[FIXING] → [FIXED]
  日志：{时间戳} | REVIEW | 重新评审修复：{编号}
  操作：调用 task-review 技能
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[FIXED] → [REVIEW] → {结果}

如果是 [DONE]（开发完成，待评审）：
  日志：{时间戳} | REVIEW | 评审已完成任务：{编号}
  操作：调用 task-review 技能
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[DONE] → [REVIEW] → {结果}

如果是 [REVIEW]：
  日志：{时间戳} | REVIEW | 继续评审任务：{编号}
  操作：调用 task-review 技能完成评审
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[REVIEW] → {结果}

如果是 [FIXED]：
  日志：{时间戳} | REVIEW | 重新评审修复：{编号}
  操作：调用 task-review 技能重新评审
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[FIXED] → [REVIEW] → {结果}

步骤 3：处理评审结果
─────────────────────────────────────────
如果评审通过 [APPROVED]：
  日志：{时间戳} | SUCCESS | 任务 {编号} 完成 [APPROVED]
  操作：更新 task-loop-status.md

如果评审拒绝 [REJECTED]：
  日志：{时间戳} | WARN | 任务 {编号} 被拒绝 [REJECTED]
  日志：{时间戳} | FIX | 开始修复任务：{编号}
  操作：调用 task-fix 技能
  日志：{时间戳} | FIX | 完成 task-fix，状态：[REJECTED] → [FIXING] → [FIXED]

  日志：{时间戳} | REVIEW | 重新评审修复：{编号}
  操作：调用 task-review 技能重新评审
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[FIXED] → [REVIEW] → {结果}

步骤 4：更新进度报告
─────────────────────────────────────────
操作：更新 task-loop-status.md
日志：{时间戳} | INFO | 更新进度报告

步骤 5：检查完成条件
─────────────────────────────────────────
操作：检查是否所有任务都是 [APPROVED]
如果全部完成：
  日志：{时间戳} | SUCCESS | 所有任务已完成！
  操作：生成最终完成报告并退出
如果未完成：
  日志：{时间戳} | INFO | 继续下一个任务
  返回步骤 1
```

## 技能调用说明

### 调用其他技能
在循环中需要调用以下技能：
1. **task-exec** - 执行任务
   ```markdown
   使用 /task-exec 技能执行当前 [TODO] 任务
   ```

2. **task-review** - 评审任务
   ```markdown
   使用 /task-review 技能评审当前 [DONE] 或 [FIXED] 任务
   ```

3. **task-fix** - 修复问题
   ```markdown
   使用 /task-fix 技能修复当前 [REJECTED] 任务
   ```

### 技能切换时机
- task-exec 完成后 → 立即调用 task-review
- task-review 通过 → 继续下一个任务
- task-review 拒绝 → 立即调用 task-fix
- task-fix 完成后 → 立即调用 task-review

## 完成条件检测

### 检查所有任务完成
```markdown
遍历 TASKS.md 中的所有任务，检查：
- 是否所有任务都是 [APPROVED] 状态
- 是否还有 [TODO], [WIP], [DONE], [REVIEW], [FIXED], [REJECTED], [FIXING]

如果全部为 [APPROVED]，输出完成报告并退出。
```

### 完成报告
```markdown
## 🎉 项目开发完成！

### 统计信息
- 总任务数：15
- 总耗时：3 天
- 评审通过率：93%（14/15）
- 修复次数：2 次

### 里程碑完成情况
- ✅ 里程碑 1 (MVP) - 8/8 完成
- ✅ 里程碑 2 (增强) - 7/7 完成

### 所有任务
✅ 01-001 初始化项目结构
✅ 01-002 配置 TypeScript
✅ 01-003 配置测试框架
✅ 01-004 实现用户模型
✅ 01-005 实现用户注册 API
✅ 01-006 实现用户登录 API
✅ 01-007 添加 JWT 认证中间件
✅ 01-008 实现权限控制
...

### Git 提交
所有更改已提交到 git 仓库。

---

## 最后提醒：持续循环

**再次强调：这个技能的核心是持续循环，直到所有任务完成。**

当调用 /task-loop 时：
1. ✅ 执行初始化
2. ✅ 开始第一个任务
3. ✅ 完成后**立即开始第二个任务**
4. ✅ 完成后**立即开始第三个任务**
5. ✅ ...
6. ✅ 直到所有任务 [APPROVED] 才停止

**不应该出现的行为：**
- ❌ 执行一个任务后停止
- ❌ 完成任务后询问用户
- ❌ 等待用户确认
- ❌ 中途退出

**应该出现的行为：**
- ✅ 持续执行任务，一个接一个
- ✅ 不等待任何确认
- ✅ 不询问用户
- ✅ 直到所有任务完成才退出

**记住：这是自动化循环，不是手动执行工具！**
