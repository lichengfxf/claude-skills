---
name: task-loop-one
description: 不要自动调用。本技能只支持用户手动调用。
---

# 单次开发循环执行

Role: 你是一位拥有 10 年经验的资深软件开发专家。你精通项目管理和自动化工作流。

你的目标是执行一次完整的开发循环：处理一个任务，执行 task-exec → task-review → task-fix（如果需要），完成后停止。

## 立即执行：初始化

**重要：当这个技能被调用时，立即执行以下初始化步骤：**

1. 检查 TASKS.md 是否存在于当前工作目录
2. 检查 CONTEXT.md 是否存在（如果不存在，警告用户但继续）
3. **创建/清空 task-loop-status.md 文件**（进度报告文件）
4. **创建/清空 task-loop-log.txt 文件**（运行日志文件）
5. 向 task-loop-log.txt 写入初始日志：
   ```
   {当前时间} | INFO  | 启动单次开发循环
   {当前时间} | INFO  | 初始化进度报告和日志文件
   ```
6. 读取并分析 TASKS.md，统计任务数量和各状态的任务数
7. **将初始进度报告写入 task-loop-status.md**

初始化完成后，立即执行单次开发循环。

## 立即执行：单次循环

**重要：初始化完成后，立即开始执行以下流程，不要等待任何确认：**

**单次执行流程（只处理一个任务，完成后停止）：**

1. 执行 /compact 压缩上下文
2. 查找下一个待处理任务（优先级：[WIP] → [FIXING] → [DONE] → [FIXED] → [REVIEW] → [TODO]）
3. 如果没有待处理任务（所有任务都是 [APPROVED]），输出完成报告并退出
4. 根据任务状态执行对应操作（见下方"任务处理流程"）
5. **完成任何状态变更后，立即更新 task-loop-status.md**
6. **完成当前任务后，停止执行，输出总结报告**
7. **不要继续下一个任务**

**关键规则（必须遵守）：**
- ✅ 完成一个任务后，停止执行，不继续
- ✅ **每次状态变更后，立即更新 task-loop-status.md**
- ✅ 评审拒绝后，修复并重新评审
- ✅ 完成任务后输出总结报告
- ✅ 提示用户如何继续
- ❌ 不要自动处理下一个任务
- ❌ 不要持续循环
- ❌ **不要忘记更新 task-loop-status.md**

**单次执行伪代码：**
```python
# 步骤 1: 压缩上下文
execute /compact

# 步骤 2: 查找待处理任务
task = find_next_task(
    priority=[WIP, FIXING, DONE, FIXED, REVIEW, TODO]
)

# 步骤 3: 检查是否全部完成
if task is None:  # 所有任务都是 [APPROVED]
    print("所有任务已完成！")
    exit  # 退出

# 步骤 4: 执行任务（只处理这一个任务）
if task.status == TODO:
    execute_task_exec(task)
    update_task_loop_status()  # ⚠️ 必须更新！
    execute_task_review(task)
    update_task_loop_status()  # ⚠️ 必须更新！
elif task.status == WIP:
    continue_task_exec(task)  # 恢复并完成
    update_task_loop_status()  # ⚠️ 必须更新！
    execute_task_review(task)
    update_task_loop_status()  # ⚠️ 必须更新！
elif task.status == REVIEW:
    continue_task_review(task)  # 完成评审
    update_task_loop_status()  # ⚠️ 必须更新！
elif task.status == DONE:
    execute_task_review(task)
    update_task_loop_status()  # ⚠️ 必须更新！
elif task.status == FIXED:
    execute_task_review(task)  # 重新评审
    update_task_loop_status()  # ⚠️ 必须更新！
elif task.status == REJECTED:
    execute_task_fix(task)
    update_task_loop_status()  # ⚠️ 必须更新！
    execute_task_review(task)
    update_task_loop_status()  # ⚠️ 必须更新！
elif task.status == FIXING:
    continue_task_fix(task)  # 恢复并完成修复
    update_task_loop_status()  # ⚠️ 必须更新！
    execute_task_review(task)
    update_task_loop_status()  # ⚠️ 必须更新！

# 步骤 5: 输出总结报告并停止
print_summary_report()
exit  # 停止执行，不继续下一个任务

# 重要：update_task_loop_status() 必须在每次状态变更后调用
# 不要跳过这个步骤！
```

## 重要：上下文管理

### 每次循环开始前
**必须使用 `/compact` 命令压缩当前会话的上下文**，以避免 Token 消耗过大和保持处理效率。

压缩上下文的操作：
```markdown
在执行任务前，执行以下步骤：

1. 执行 /compact 命令压缩上下文
2. 等待上下文压缩完成
3. 读取当前任务信息（任务编号、描述、状态）
4. 读取必要文件：
   - TASKS.md（查看任务状态）
   - CONTEXT.md（获取项目上下文，如果存在）
   - task-{编号}.review（对应的评审报告，如果存在）
5. 继续执行当前任务
```

重要提示：
- **在初始化完成后立即执行一次 /compact**，压缩加载技能文件的上下文
- **在 task-exec、task-review、task-fix 之间也执行 /compact**

这样做的好处：
- 大幅减少 Token 消耗
- 提高响应速度
- 避免上下文过长导致的质量下降
- 每个任务都"重新开始"，更符合真实开发流程

### 文件输出
- **进度报告**：`task-loop-status.md` - 实时更新的当前状态
- **运行日志**：`task-loop-log.txt` - 完整的操作日志

## 工作流程

### 单次执行流程
```
┌─────────────────────────────────────────────────────────┐
│  1. 读取 TASKS.md，查找待处理的任务                      │
│     按优先级查找：                                      │
│     - 查找 [WIP] 任务（开发进行中被打断）⭐ 最高优先级  │
│     - 查找 [FIXING] 任务（修复进行中被打断）            │
│     - 查找 [DONE] 任务（开发完成，待评审）              │
│     - 查找 [FIXED] 任务（修复完成，待重新评审）          │
│     - 查找 [REVIEW] 任务（评审中）                      │
│     - 查找 [TODO] 任务（待开发）                        │
└─────────────────────────────────────────────────────────┘
                    ↓
            是否有待处理任务？
                    ↓
         ┌──────────┴──────────┐
         │ 是                   │ 否
         ↓                      ↓
┌──────────────────┐    ┌─────────────────┐
│ 2. 确定任务类型   │    │ 所有任务已完成   │
│    - [TODO]      │    │ 输出完成报告     │
│      → 执行      │    │ 退出             │
│    - [REVIEW]    │    └─────────────────┘
│      → 评审      │
│    - [FIXED]     │
│      → 评审      │
└──────────────────┘
         ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 根据任务类型执行相应操作                             │
│                                                          │
│    情况 A: [TODO] 任务                                   │
│    ┌────────────────────────────────────────────┐       │
│    │ 3.1 调用 task-exec 执行任务                 │       │
│    │     - 将 [TODO] 改为 [WIP]                   │       │
│    │     - 实现功能代码                           │       │
│    │     - 将 [WIP] 改为 [DONE]                   │       │
│    │     - 提交代码                               │       │
│    └────────────────────────────────────────────┘       │
│                    ↓                                     │
│    ┌────────────────────────────────────────────┐       │
│    │ 3.2 调用 task-review 评审任务               │       │
│    │     - 将 [DONE] 改为 [REVIEW]                │       │
│    │     - 创建评审报告文件                       │       │
│    │     - 判断：通过 [APPROVED] 或拒绝 [REJECTED]│     │
│    └────────────────────────────────────────────┘       │
│                    ↓                                     │
│         ┌──────────┴──────────┐                         │
│         │ 通过                 │ 拒绝                    │
│         ↓                      ↓                         │
│    ┌─────────┐         ┌──────────────────┐             │
│    │  停止   │         │ 3.3 调用 task-fix │             │
│    │  输出   │         │     - 将 [REJECTED]│            │
│    │  报告   │         │       改为 [FIXING] │            │
│    └─────────┘         │     - 修复问题     │            │
│                        │     - 将 [FIXING]  │            │
│                        │       改为 [FIXED]  │            │
│                        │     - 提交修复代码  │            │
│                        └───────────────────┘            │
│                               ↓                          │
│                    ┌────────────────────────────────────┐│
│                    │ 3.4 重新调用 task-review            ││
│                    │     - 将 [FIXED] 改为 [REVIEW]      ││
│                    │     - 更新评审报告                  ││
│                    │     - 判断：通过或拒绝              ││
│                    └────────────────────────────────────┘│
│                               ↓                          │
│                    ┌──────────┴──────────┐              │
│                    │ 通过                 │ 拒绝          │
│                    ↓                      ↓              │
│               ┌─────────┐         回到 3.3              │
│               │  停止   │                               │
│               │  输出   │                               │
│               │  报告   │                               │
│               └─────────┘                               │
│                                                          │
│    情况 B: [REVIEW] 任务（遗留任务）                     │
│    ┌────────────────────────────────────────────┐       │
│    │ 直接调用 task-review 完成评审                │       │
│    │     - 将 [REVIEW] 改为 [APPROVED]/[REJECTED]│      │
│    └────────────────────────────────────────────┘       │
│                    ↓                                     │
│               停止并输出报告                             │
│                                                          │
│    情况 C: [FIXED] 任务（修复后待重新评审）              │
│    ┌────────────────────────────────────────────┐       │
│    │ 直接调用 task-review 重新评审                │       │
│    │     - 将 [FIXED] 改为 [REVIEW]               │       │
│    │     - 将 [REVIEW] 改为 [APPROVED]/[REJECTED]│      │
│    └────────────────────────────────────────────┘       │
│                    ↓                                     │
│               停止并输出报告                             │
│                                                          │
│    情况 D: [WIP] 任务（开发进行中被打断）                │
│    ┌────────────────────────────────────────────┐       │
│    │ 继续完成当前任务                            │       │
│    │     - 读取当前进度和已完成的代码             │       │
│    │     - 继续开发直到完成                       │       │
│    │     - 将 [WIP] 改为 [DONE]                  │       │
│    │     - 然后调用 task-review                  │       │
│    └────────────────────────────────────────────┘       │
│                    ↓                                     │
│               停止并输出报告                             │
│                                                          │
│    情况 E: [FIXING] 任务（修复进行中被打断）              │
│    ┌────────────────────────────────────────────┐       │
│    │ 继续完成修复                                │       │
│    │     - 读取评审意见和当前修复进度             │       │
│    │     - 继续修复直到完成                       │       │
│    │     - 将 [FIXING] 改为 [FIXED]              │       │
│    │     - 然后调用 task-review 重新评审          │       │
│    └────────────────────────────────────────────┘       │
│                    ↓                                     │
│               停止并输出报告                             │
│                                                          │
│    情况 F: [DONE] 任务（开发完成，待评审）                │
│    ┌────────────────────────────────────────────┐       │
│    │ 直接调用 task-review 评审                   │       │
│    │     - 将 [DONE] 改为 [REVIEW]               │       │
│    │     - 将 [REVIEW] 改为 [APPROVED]/[REJECTED]│      │
│    └────────────────────────────────────────────┘       │
│                    ↓                                     │
│               停止并输出报告                             │
└─────────────────────────────────────────────────────────┘
         ↓
    输出总结报告并停止
```

## 执行规则

### 优先级处理顺序
处理任务时的优先级（从高到低）：
1. **[WIP]** - 开发进行中被打断，优先完成当前任务
2. **[FIXING]** - 修复进行中被打断，优先完成修复
3. **[DONE]** - 开发完成但未评审，需要评审
4. **[FIXED]** - 修复完成待重新评审
5. **[REVIEW]** - 评审中的任务
6. **[TODO]** - 新任务按顺序执行

**原因**：中间状态的任务（WIP、FIXING、DONE）表示已经投入了工作，应该优先完成，避免浪费已有进展。

### 任务查找规则
```markdown
优先查找：[WIP] → [FIXING] → [DONE] → [FIXED] → [REVIEW] → [TODO]

在同一优先级内，按编号顺序：
- 01-001, 01-002, 01-003...
- 02-001, 02-002, 02-003...
```

### 中断恢复说明
当技能被重新调用时：
1. 检查是否有 [WIP] 或 [FIXING] 任务（进行中的任务）
2. 如果有，优先恢复这些任务
3. 如果没有，检查 [DONE] 或 [FIXED] 任务（待评审的任务）
4. 最后处理 [TODO] 任务（新任务）

这样可以确保：
- 不会重复开始已进行中的任务
- 已完成的工作不会丢失
- 任务流程的连续性

### 状态转换规则
```markdown
# 开发流程
[TODO] → [WIP] → [DONE] → [REVIEW]

# 评审流程
[REVIEW] → [APPROVED]  # 通过
[REVIEW] → [REJECTED]  # 拒绝

# 修复流程
[REJECTED] → [FIXING] → [FIXED] → [REVIEW]

# 重新评审
[FIXED] → [REVIEW] → [APPROVED]/[REJECTED]
```

### 中断和恢复
- **遇到错误时**：记录错误信息，停止执行，让用户决定是否继续
- **遇到冲突时**：提示用户解决冲突，等待用户恢复
- **手动干预**：用户可随时停止，手动调整任务状态

## 完成输出

### 总结报告（输出到控制台）
完成当前任务后，输出总结报告：

```markdown
## 单次开发循环 - 完成报告

### 当前处理的任务
- ✅ 01-005 实现登录 API [APPROVED]
- 或 ⚠️ 01-005 实现登录 API [REJECTED] - 已修复并重新评审

### 项目整体状态
- 总任务数：15
- 已完成：8 [APPROVED]
- 进行中：1 [WIP]
- 待评审：1 [DONE]
- 评审中：1 [REVIEW]
- 待开发：3 [TODO]
- 修复中：1 [FIXING]

### 下一步
- ⏭️ 下一个待处理任务：01-006 实现登出功能 [TODO]

### 继续执行
如需继续处理下一个任务，请重新调用：
  /task-loop-one

或使用持续循环版本：
  /task-loop
```

### 进度报告（输出到 task-loop-status.md）
完成任务后，更新进度报告文件：

```markdown
# 单次开发循环 - 进度报告

更新时间：2025-02-24 16:30:00

## 当前状态
- 总任务数：15
- 已完成：8 [APPROVED]
- 进行中：1 [WIP]
- 待评审：1 [DONE]
- 评审中：1 [REVIEW]
- 待开发：3 [TODO]
- 修复中：1 [FIXING]

## 最近完成
- ✅ 01-005 实现登录 API [APPROVED]

## 下一步
- ⏭️ 将处理：01-006 实现登出功能

## 里程碑进度
- 🎯 里程碑 1 (MVP)：7/8 完成
- 🎯 里程碑 2 (增强)：1/7 完成
```

### 运行日志（输出到 task-loop-log.txt）
记录所有操作到日志文件：

```
2025-02-24 10:00:00 | INFO  | 启动单次开发循环
2025-02-24 10:00:01 | INFO  | 读取 TASKS.md
2025-02-24 10:00:02 | INFO  | 发现 15 个任务，8 个已完成
2025-02-24 10:00:03 | INFO  | 初始化进度报告和日志文件
2025-02-24 10:00:04 | INFO  | 执行 /compact 压缩上下文
2025-02-24 10:00:05 | INFO  | 上下文已压缩
2025-02-24 10:00:06 | TASK  | 读取任务 01-009：实现登录 API
2025-02-24 10:00:07 | TASK  | 执行 task-exec：01-009 实现登录 API
2025-02-24 10:15:30 | TASK  | 完成 task-exec，状态：[WIP] → [DONE]
2025-02-24 10:15:31 | INFO  | 执行 /compact 压缩上下文
2025-02-24 10:15:32 | INFO  | 上下文已压缩
2025-02-24 10:15:33 | REVIEW | 执行 task-review：01-009
2025-02-24 10:20:15 | REVIEW | 完成 task-review，状态：[REVIEW] → [APPROVED]
2025-02-24 10:20:16 | SUCCESS | 任务 01-009 完成 [APPROVED]
2025-02-24 10:20:17 | INFO  | 更新进度报告
2025-02-24 10:20:18 | INFO  | 单次开发循环完成
```

日志格式：
```
时间戳 | 级别 | 消息
```

日志级别：
- **INFO** - 一般信息
- **TASK** - 任务执行
- **REVIEW** - 评审操作
- **FIX** - 修复操作
- **WARN** - 警告
- **ERROR** - 错误
- **SUCCESS** - 成功完成

## 使用说明

### 启动单次执行
调用本技能（/task-loop-one）时，会自动执行初始化并处理一个任务。

### 从特定任务开始
如果需要从特定任务开始，可以在调用技能前：
1. 将该任务之前所有任务标记为 [APPROVED]
2. 将该任务标记为 [TODO]（或其他需要恢复的状态）
3. 调用 /task-loop-one

技能会：
1. 执行初始化（创建/清空状态和日志文件）
2. 读取当前状态
3. 处理第一个未完成的任务
4. 完成后停止并输出报告

### 暂停和恢复
- **暂停**：任务完成后自动停止
- **恢复**：重新调用 /task-loop-one 继续处理下一个任务

## 注意事项

### 安全检查
每次执行开始前检查：
- 不修改核心技能文件（task-*/SKILL.md）
- 不删除或破坏用户数据
- 不提交包含敏感信息的代码

### 最佳实践
1. **首次运行前**：
   - 确保 TASKS.md 已正确创建
   - 确保项目结构已初始化
   - 建议先手动执行第一个任务验证流程

2. **运行期间**：
   - 定期检查 git 提交历史
   - 查看评审报告文件
   - 监控进度报告

3. **遇到问题时**：
   - 检查 TASKS.md 中的任务状态
   - 查看对应的 .review 文件
   - 可以手动调整状态后重新执行

### 日志记录
**重要**：所有日志都记录到 `task-loop-log.txt` 文件中，而不是 TASKS.md。

每次操作都要追加日志到 task-loop-log.txt，包括：
- 启动
- 当前任务的开始和完成
- 状态转换
- 评审结果
- 修复操作
- 错误和警告
- 进度更新

### 任务执行流程

### 单次执行的标准流程

```markdown
步骤 0：压缩上下文（最优先）
─────────────────────────────────────────
操作：执行 /compact 命令
日志：{时间戳} | INFO | 执行 /compact 压缩上下文
说明：在开始任务前，先压缩上下文以减少 Token 消耗

步骤 1：读取任务信息
─────────────────────────────────────────
操作：从 TASKS.md 读取当前任务的完整信息
日志：{时间戳} | TASK | 读取任务 {编号}：{描述}

步骤 2：执行任务（根据状态）
─────────────────────────────────────────
如果是 [TODO]：
  日志：{时间戳} | TASK | 执行 task-exec：{编号} {描述}
  操作：调用 task-exec 技能
  日志：{时间戳} | TASK | 完成 task-exec，状态：[TODO] → [WIP] → [DONE]
  ⚠️ **必须更新 task-loop-status.md**

  日志：{时间戳} | REVIEW | 执行 task-review：{编号}
  操作：调用 task-review 技能
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[DONE] → [REVIEW] → {结果}
  ⚠️ **必须更新 task-loop-status.md**

如果是 [WIP]（开发进行中被打断）：
  日志：{时间戳} | INFO | 恢复开发中任务：{编号}
  操作：读取当前进度和已完成的代码，继续开发
  日志：{时间戳} | TASK | 继续开发，状态：[WIP] → [DONE]
  ⚠️ **必须更新 task-loop-status.md**

  日志：{时间戳} | REVIEW | 执行 task-review：{编号}
  操作：调用 task-review 技能
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[DONE] → [REVIEW] → {结果}
  ⚠️ **必须更新 task-loop-status.md**

如果是 [FIXING]（修复进行中被打断）：
  日志：{时间戳} | INFO | 恢复修复中任务：{编号}
  操作：读取评审意见和当前修复进度，继续修复
  日志：{时间戳} | FIX | 继续修复，状态：[FIXING] → [FIXED]
  ⚠️ **必须更新 task-loop-status.md**

  日志：{时间戳} | REVIEW | 重新评审修复：{编号}
  操作：调用 task-review 技能
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[FIXED] → [REVIEW] → {结果}
  ⚠️ **必须更新 task-loop-status.md**

如果是 [DONE]（开发完成，待评审）：
  日志：{时间戳} | REVIEW | 评审已完成任务：{编号}
  操作：调用 task-review 技能
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[DONE] → [REVIEW] → {结果}
  ⚠️ **必须更新 task-loop-status.md**

如果是 [REVIEW]：
  日志：{时间戳} | REVIEW | 继续评审任务：{编号}
  操作：调用 task-review 技能完成评审
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[REVIEW] → {结果}
  ⚠️ **必须更新 task-loop-status.md**

如果是 [FIXED]：
  日志：{时间戳} | REVIEW | 重新评审修复：{编号}
  操作：调用 task-review 技能重新评审
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[FIXED] → [REVIEW] → {结果}
  ⚠️ **必须更新 task-loop-status.md**

步骤 3：处理评审结果
─────────────────────────────────────────
如果评审通过 [APPROVED]：
  日志：{时间戳} | SUCCESS | 任务 {编号} 完成 [APPROVED]
  操作：更新 task-loop-status.md

如果评审拒绝 [REJECTED]：
  日志：{时间戳} | WARN | 任务 {编号} 被拒绝 [REJECTED]
  日志：{时间戳} | FIX | 开始修复任务：{编号}
  操作：调用 task-fix 技能
  日志：{时间戳} | FIX | 完成 task-fix，状态：[REJECTED] → [FIXING] → [FIXED]

  日志：{时间戳} | REVIEW | 重新评审修复：{编号}
  操作：调用 task-review 技能重新评审
  日志：{时间戳} | REVIEW | 完成 task-review，状态：[FIXED] → [REVIEW] → {结果}

步骤 4：更新进度报告
─────────────────────────────────────────
操作：更新 task-loop-status.md
日志：{时间戳} | INFO | 更新进度报告

步骤 5：输出总结报告并停止
─────────────────────────────────────────
操作：输出总结报告到控制台
日志：{时间戳} | INFO | 单次开发循环完成
操作：停止执行
```

## 技能调用说明

### 调用其他技能
在执行中需要调用以下技能：
1. **task-exec** - 执行任务
   ```markdown
   使用 /task-exec 技能执行当前 [TODO] 任务
   ```

2. **task-review** - 评审任务
   ```markdown
   使用 /task-review 技能评审当前 [DONE] 或 [FIXED] 任务
   ```

3. **task-fix** - 修复问题
   ```markdown
   使用 /task-fix 技能修复当前 [REJECTED] 任务
   ```

### 技能切换时机
- task-exec 完成后 → 立即调用 task-review
- task-review 通过 → 停止并输出报告
- task-review 拒绝 → 立即调用 task-fix
- task-fix 完成后 → 立即调用 task-review

## 完成条件检测

### 检查所有任务完成
```markdown
遍历 TASKS.md 中的所有任务，检查：
- 是否所有任务都是 [APPROVED] 状态
- 是否还有 [TODO], [WIP], [DONE], [REVIEW], [FIXED], [REJECTED], [FIXING]

如果全部为 [APPROVED]，输出完成报告并退出。
```

### 完成报告
```markdown
## 🎉 项目开发完成！

### 统计信息
- 总任务数：15
- 评审通过率：93%（14/15）
- 修复次数：2 次

### 里程碑完成情况
- ✅ 里程碑 1 (MVP) - 8/8 完成
- ✅ 里程碑 2 (增强) - 7/7 完成

### 所有任务
✅ 01-001 初始化项目结构
✅ 01-002 配置 TypeScript
✅ 01-003 配置测试框架
✅ 01-004 实现用户模型
✅ 01-005 实现用户注册 API
✅ 01-006 实现用户登录 API
✅ 01-007 添加 JWT 认证中间件
✅ 01-008 实现权限控制
...

### Git 提交
所有更改已提交到 git 仓库。
```

## 最后提醒：单次执行

**再次强调：这个技能只执行一次开发循环，处理一个任务后停止。**

当调用 /task-loop-one 时：
1. ✅ 执行初始化
2. ✅ 处理一个任务
3. ✅ 完成后**停止并输出报告**
4. ✅ 需要继续时，重新调用 /task-loop-one

**不应该出现的行为：**
- ❌ 执行一个任务后自动继续下一个
- ❌ 持续循环不需要用户干预
- ❌ 处理多个任务后才停止
- ❌ **忘记更新 task-loop-status.md**

**应该出现的行为：**
- ✅ 只处理一个任务
- ✅ 完成后停止
- ✅ 输出总结报告
- ✅ 提示用户如何继续
- ✅ **每次状态变更后，立即更新 task-loop-status.md**

**记住：这是单次执行工具，不是持续循环工具！**
**记住：task-loop-status.md 必须实时更新，不要遗漏！**
